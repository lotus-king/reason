
/**
 * Reason
 * Copyright (C) 2009  Emerson Clarke
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */


#ifndef PLATFORM_THREAD_H
#define PLATFORM_THREAD_H

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "reason/reason.h"
#include "reason/platform/platform.h"
#include "reason/generic/generic.h"
#include "reason/messaging/callback.h"

using namespace Reason::Generic;
using namespace Reason::Messaging;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <string.h>
#include <assert.h>

#ifdef REASON_PLATFORM_WINDOWS

	#include <process.h>    

#endif

#ifdef REASON_PLATFORM_POSIX
	#include <semaphore.h>
	#include <pthread.h>
	#include <errno.h>
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace Reason { namespace Platform {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Critical
{
public:

	static const unsigned int TimeoutDefault = 30000;
	static const unsigned int TimeoutImmediate = 0;
	static const unsigned int TimeoutInfinite = 0xFFFFFFFF;

	#ifdef REASON_PLATFORM_WINDOWS

		CRITICAL_SECTION Handle;	

	#endif

	#ifdef REASON_PLATFORM_POSIX

		pthread_mutex_t Handle;		

	#endif

	Critical();

	~Critical();

	bool Enter();
	bool Leave();
	bool Try();

	bool Wait();
	bool Owned();

	void Create();
	void Delete();

	class Auto;

};

class Critical::Auto
{
public:

	Reason::Platform::Critical * Mutex;

	Auto():Mutex(0)
	{

	}

	Auto(Auto & automatic)
	{
		Mutex = automatic.Mutex;
		automatic.Mutex = 0;
	}

	Auto(Reason::Platform::Critical & mutex):Mutex(&mutex)
	{
		if (Mutex) Mutex->Enter();
	}

	Auto(Reason::Platform::Critical * mutex):Mutex(mutex)
	{
		if (Mutex) Mutex->Enter();
	}

	~Auto()
	{
		if (Mutex) Mutex->Leave();
	}

	Auto & operator = (Reason::Platform::Critical * mutex)
	{
		if (Mutex) Mutex->Leave();
		Mutex = mutex;
		if (Mutex) Mutex->Enter();
		return *this;
	}

	Auto & operator = (Reason::Platform::Critical & mutex)
	{
		return operator = (&mutex);
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Mutex
{
public:

	static const unsigned int TimeoutDefault = 30000;
	static const unsigned int TimeoutImmediate = 0;
	static const unsigned int TimeoutInfinite = 0xFFFFFFFF;

	volatile unsigned long Id;

	#ifdef REASON_PLATFORM_WINDOWS

		void * Handle;	

	#endif

	#ifdef REASON_PLATFORM_POSIX
		pthread_mutex_t Handle;		

	#endif

	Mutex()
	{
		Create();
	}

	~Mutex()
	{
		Delete();
	}

	bool Lock(int timeout=TimeoutInfinite);
	bool Unlock();

	bool Try();

	bool Wait(int timeout=TimeoutImmediate);

	void Create();
	void Delete();

	class Auto;

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Mutex::Auto
{
public:

	Reason::Platform::Mutex * Mutex;

	Auto():Mutex(0)
	{

	}

	Auto(Auto & automatic)
	{
		Mutex = automatic.Mutex;
		automatic.Mutex = 0;
	}

	Auto(Reason::Platform::Mutex & mutex):Mutex(&mutex)
	{
		if (Mutex) Mutex->Lock();
	}

	Auto(Reason::Platform::Mutex * mutex):Mutex(mutex)
	{
		if (Mutex) Mutex->Lock();
	}

	~Auto()
	{
		if (Mutex) Mutex->Unlock();
	}

	Auto & operator = (Reason::Platform::Mutex * mutex)
	{
		if (Mutex) Mutex->Unlock();
		Mutex = mutex;
		if (Mutex) Mutex->Lock();
		return *this;
	}

	Auto & operator = (Reason::Platform::Mutex & mutex)
	{
		return operator = (&mutex);
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Lock
{
public:

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Event
{
public:

	static const unsigned int TimeoutDefault = 30000;
	static const unsigned int TimeoutImmediate = 0;
	static const unsigned int TimeoutInfinite = 0xFFFFFFFF;

	void * Handle;

	struct EventWait;	
	struct EventObject;

	Reason::Platform::Mutex Mutex;	

	Event(bool manual=false, bool set=false);
	~Event();

	bool Set();
	bool Reset();
	bool Pulse();

	bool Wait(int timeout=Event::TimeoutInfinite);

	static int WaitForMultipleEvents(int count, Event * events, bool all=false, int timeout=Event::TimeoutInfinite);
	static int WaitForSingleEvent(Event * event, int timeout=Event::TimeoutInfinite);

protected:

	static bool WaitForEvent(Event * event, int timeout=Event::TimeoutInfinite);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Condition
{
public:

	static const unsigned int TimeoutDefault = 30000;
	static const unsigned int TimeoutImmediate = 0;
	static const unsigned int TimeoutInfinite = 0xFFFFFFFF;

	#ifdef REASON_PLATFORM_POSIX
	pthread_cond_t Handle;
	#endif

	#ifdef REASON_PLATFORM_WINDOWS

	#if REASON_PLATFORM_WINVER >= 0x0600

	CONDITION_VARIABLE Handle;
	#else

	struct ConditionObject
	{
		enum ConditionEvents
		{
			SIGNAL=0,
			BROADCAST=1
		};

		void * Events[2];
		int Signal;

		ConditionObject()
		{

			Events[SIGNAL] = CreateEvent(0,false,false,0);

			Events[BROADCAST] = CreateEvent(0,true,false,0);
			Signal = 0;
		}

		~ConditionObject()
		{
			CloseHandle((HANDLE)Events[SIGNAL]);
			CloseHandle((HANDLE)Events[BROADCAST]);
		}
	};

	ConditionObject Handle;
	#endif

	#endif

	Reason::Platform::Critical Critical;

	Condition();
	~Condition();

	bool Wait() {return Wait(TimeoutInfinite);}
	bool Wait(unsigned int timeout);

	bool Enter() {return Critical.Enter();}
	bool Leave() {return Critical.Leave();}
	bool Try() {return Critical.Try();}

	bool Signal();
	bool Broadcast();
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Semaphore
{
public:

#ifdef REASON_PLATFORM_WINDOWS
	void * Handle;
#endif
#ifdef REASON_PLATFORM_POSIX

	sem_t * Handle;
#endif

	Semaphore(int count=0);
	~Semaphore();

	bool Enter();
	bool Leave();

	class Auto;
};

class Semaphore::Auto
{
public:

	Reason::Platform::Semaphore * Semaphore;

	Auto():Semaphore(0)
	{

	}

	Auto(Auto & automatic)
	{
		Semaphore = automatic.Semaphore;
		automatic.Semaphore = 0;
	}

	Auto(Reason::Platform::Semaphore & semaphore):Semaphore(&semaphore)
	{
		if (Semaphore) Semaphore->Enter();
	}

	Auto(Reason::Platform::Semaphore * semaphore):Semaphore(semaphore)
	{
		if (Semaphore) Semaphore->Enter();
	}

	~Auto()
	{
		if (Semaphore) Semaphore->Leave();
	}

	Auto & operator = (Reason::Platform::Semaphore * semaphore)
	{
		if (Semaphore) Semaphore->Leave();
		Semaphore = semaphore;
		if (Semaphore) Semaphore->Enter();
		return *this;
	}

	Auto & operator = (Reason::Platform::Semaphore & semaphore)
	{
		return operator = (&semaphore);
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Locked : private Critical
{
public:

	volatile unsigned int Id;

	Locked():Id(0){}

	bool Lock();

	bool IsLocked()
	{
		return Id != 0;
	}

	bool Unlock()
	{
		Enter();
		Id = 0;
		Leave();
		return true;
	}

	bool IsUnlocked()
	{
		return Id == 0;
	}

	bool Wait(bool lock=false)
	{

		return lock?IsUnlocked():IsLocked();

	}

	bool Owned();

	class Auto;
};

class Locked::Auto
{
public:

	Reason::Platform::Locked * Locked;

	Auto():Locked(0)
	{

	}

	Auto(Auto & automatic)
	{
		Locked = automatic.Locked;
		automatic.Locked = 0;
	}

	Auto(Reason::Platform::Locked & lock):Locked(&lock)
	{
		if (Locked) Locked->Lock();
	}

	Auto(Reason::Platform::Locked * lock):Locked(lock)
	{
		if (Locked) Locked->Lock();
	}

	~Auto()
	{
		if (Locked) Locked->Unlock();
	}

	Auto & operator = (Reason::Platform::Locked * lock)
	{
		if (Locked) Locked->Unlock();
		Locked = lock;
		if (Locked) Locked->Lock();
		return *this;
	}

	Auto & operator = (Reason::Platform::Locked & lock)
	{
		return operator = (&lock);
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Blocked : public Locked
{
public:

	Reason::Platform::Critical Mutex;

	bool IsBlocking();

	bool Blocking()
	{
		if (IsLocked())
		{
			Mutex.Enter();
			Mutex.Leave();
			return true;
		}

		return false;
	}

	void Block()
	{
		Mutex.Enter();
		Lock();
	}

	void Unblock()
	{
		Unlock();
		Mutex.Leave();
	}

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Protected 
{
public:

	Reason::Platform::Blocked Blocked;
	Reason::Platform::Semaphore Semaphore;

	void Enter()
	{
		Blocked.Blocking();
		Semaphore.Enter();
	}

	bool IsProtected()
	{
		return Blocked.IsBlocking();
	}

	void Leave()
	{
		Semaphore.Leave();
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Monitor : private Critical
{
public:

	Critical MonitorMutex;
	volatile unsigned int MonitorId;

	Monitor():MonitorId(0){}

	bool Lock();

	bool IsLocked()
	{
		return MonitorId != 0;
	}

	bool Unlock();

	bool IsUnlocked()
	{
		return MonitorId == 0;
	}

	bool Wait(bool lock=false)
	{

		return lock?IsUnlocked():IsLocked();

	}

	bool Owned();

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

template<typename _Kind_>
class Volatile
{
public:

	Reason::Platform::Critical * Mutex;
	_Kind_ * Kind;

	Volatile(volatile typename Template<_Kind_>::ConstantReference kind, Reason::Platform::Critical & mutex):
		Mutex(&mutex), Kind(kind)
	{
		this->Mutex.Enter();		
	}

	~Volatile()
	{
		this->Mutex.Leave();
	}

	_Kind_ * operator -> () const
    {
		OutputAssert(Kind != 0);
		return Kind;
    }

    _Kind_ & operator * () const
    {
		OutputAssert(Kind != 0);
		return *Kind;
    }

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Thread;

class Runnable
{
public:

	Event Lock;
	Event Timer;

	virtual void Run(Thread * thread)
	{
	}

	virtual void Run(void *)
	{	
	}

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Thread
{
public:

	Reason::Platform::Runnable * Runnable;
	void * Context;

    Strong<void *,Shared> Handle;	

    unsigned long Id;

	Thread(Reason::Platform::Runnable * runnable, void * pointer=0);
	Thread(Reason::Platform::Runnable & runnable, void * pointer=0);
	Thread(const Thread & thread);
	Thread();
	~Thread();

	Thread & operator = (Thread & thread);

	void Start();		
	void Stop();
	void Join();
	void Kill();

	static void Sleep(unsigned long milliseconds = 1000);

	static unsigned long Identify();

	static void Pause();

	static Thread Start(Reason::Platform::Runnable * runnable, void * pointer);

protected:

	#ifdef REASON_PLATFORM_WINDOWS
		static unsigned int __stdcall Spawn(void * spawn);
	#endif

	#ifdef REASON_PLATFORM_POSIX
		static void * Spawn(void * spawn);
	#endif

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Threaded : public Runnable
{
public:

	class List
	{
	public:

		Reason::Platform::Critical Critical;	

		class Entry
		{
		public:

			Reason::Platform::Thread Thread;

			Entry * Prev;
			Entry * Next;

			Entry():Prev(0),Next(0)
			{
			}

			Entry(Reason::Platform::Thread & thread):Thread(thread),Prev(0),Next(0)
			{
			}

			Entry(Reason::Platform::Runnable * runnable):Thread(runnable),Prev(0),Next(0)
			{
			}
		};

		Entry * First;
		Entry * Last;

		int		Count;

		List();
		~List();

		Reason::Platform::Thread operator [] (int index);

		void Insert(Thread & thread) {Insert(new Entry(thread));}
		void Insert(Entry * entry);
		void Delete(Thread & thread);
		void Delete(unsigned int id);
		void Delete(Entry * entry);	

		Entry * Select(unsigned int id);
		Entry * Select(Thread & thread);

	};

public:

	Reason::Platform::Critical Critical;	
	Threaded::List Threads;

	Threaded();	
	~Threaded();

	bool Lock();		
	bool Unlock();		

	void Run(Reason::Platform::Thread * thread)
	{

		Run((void*)thread);
		Threads.Delete(*thread);

	}

	void Run(void * thread)
	{

	}

	Thread Start();	
	void Stop(unsigned int id);
	void Kill(unsigned int id);	
	void Join(unsigned int id);

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Fibre
{
public:

	Reason::Platform::Thread Thread;
	Reason::Messaging::Callback<void, void *> Callback;
	void * Context;

	class Runner : public Runnable
	{
		void Run(Reason::Platform::Thread * thread)
		{
			Fibre * fibre = (Fibre*)thread->Context;

			fibre->Thread = *thread;
			fibre->Callback((void*)fibre);
			delete fibre;
		}
	};

	static Runner Run;

	Fibre():Thread(0),Context(0)
	{

	}

	Fibre(Fibre & fibre):
		Thread(fibre.Thread),Callback(fibre.Callback),Context(fibre.Context)
	{		
	}

	Fibre(const Reason::Messaging::Callback<void, void *> callback, void * pointer=0):
		Thread(0),Callback(callback),Context(pointer)
	{
	}

	Fibre & operator = (Fibre & fibre)
	{
		Thread = fibre.Thread;
		Callback = fibre.Callback;
		Context = fibre.Context;
		return *this;
	}	

	~Fibre()
	{
	}

	Fibre & Start();
	void Join();
	void Stop();

	static Fibre & Start(Reason::Messaging::Callback<void, void *> callback, void * context=0);
	static void Join(Fibre & fibre);
	static void Stop(Fibre & fibre);

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Pool
{
public:

	int Count;
	class Wait : public Condition {};

	class Worker : public Runnable
	{
		enum State
		{
			STATE_SUSPENDED = 1,
			STATE_LOCKED	= 2,
		};

		Reason::Messaging::Callback<void, void *> Callback;
		Bitmask8 State;

		void Run(void * thread)
		{

		}

		void Run(Reason::Platform::Thread * thread)
		{
			Pool * pool = (Pool*)thread->Context;

			while (pool->Count > 0)
			{
				Callback((void*)thread);
			}	
		}
	};

};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Tls
{
public:

	void Put(int index, void * data);
	void * Get(int index);

};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif

