
/**
 * Reason
 * Copyright (C) 2009  Emerson Clarke
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */


#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdarg.h>

#include "reason/system/logging/logging.h"
#include "reason/system/storage/drive.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using namespace Reason::System::Logging;
using namespace Reason::System::Storage;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Log::Message(const char * format, ...)
{
	va_list va;
	va_start(va, format);
	PrintVa(format,va);
	va_end(va);
}

void Log::Message()
{
	Print("\n");
}

void Log::Trace(const char * format, ...)
{
	Print("[TRACE] ");
	Print("[TIME:%s] ",Time().Print());

	va_list va;
	va_start(va, format);
	PrintVa(format,va);
	va_end(va);
}

void Log::Trace()
{
	Trace("\n");
}

void Log::Alert(const char * format, ...)
{
	Print("[ALERT] ");
	Print("[TIME:%s] ",Time().Print());

	va_list va;
	va_start(va, format);
	PrintVa(format,va);
	va_end(va);
}

void Log::Alert()
{
	Alert("\n");
}

void Log::Warning(const char * format, ...)
{
	Print("[WARNING] ");
	Print("[TIME:%s] ",Time().Print());

	va_list va;
	va_start(va, format);
	PrintVa(format,va);
	va_end(va);
}

void Log::Warning()
{
	Warning("\n");
}

void Log::Critical(const char * format, ...)
{
	Print("[CRITICAL] ");
	Print("[TIME:%s] ",Time().Print());

	va_list va;
	va_start(va, format);
	PrintVa(format,va);
	va_end(va);
}

void Log::Critical()
{
	Critical("\n");
}

void Log::Error(const char * format, ...)
{
	Print("[ERROR] ");
	Print("[TIME:%s] ",Time().Print());

	va_list va;
	va_start(va, format);
	PrintVa(format,va);
	va_end(va);
}

void Log::Error()
{
	Error("\n");
}

void Log::Failure(const char * format, ...)
{
	Print("[FAILURE] ");
	Print("[TIME:%s] ",Time().Print());

	va_list va;
	va_start(va, format);
	PrintVa(format,va);
	va_end(va);
}

void Log::Failure()
{
	Failure("\n");
}

void Log::Print(const char * format, ...)
{
	va_list va;
	va_start(va, format);
	PrintVa(format,va);
	va_end(va);
}

void Log::Print()
{
	Print("\n");
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Logged::PrintVa(const char * format, va_list va)
{
	if (Handle)
	{
		vfprintf(Handle,format,va);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void Logger::PrintVa(const char * format, va_list va)
{
	Reason::System::File * file = (Reason::System::File*)this;
	Reason::System::FileStorage * store = file->Storage;

	if (store->InstanceOf(Reason::System::Storage::DriveFile::Instance))
	{
		Reason::System::Storage::DriveFile * fs = (Reason::System::Storage::DriveFile*)store;
		if (fs->Handle)
		{
			vfprintf(fs->Handle,format,va);
			return;
		}
	}

	String string;
	Formatter::FormatVa(string,format,va);
	file->Write(string);

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void LogFile::PrintVa(const char * format, va_list va)
{
	Reason::System::File * file = (Reason::System::File*)this;
	Reason::System::FileStorage * sys = file->Storage;

	if (sys->InstanceOf(Reason::System::Storage::DriveFile::Instance))
	{
		Reason::System::Storage::DriveFile * fs = (Reason::System::Storage::DriveFile*)sys;
		if (fs->Handle)
		{
			vfprintf(fs->Handle,format,va);
			return;
		}
	}

	String string;
	Formatter::FormatVa(string,format,va);
	file->Write(string);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void LogStream::PrintVa(const char * format, va_list va)
{
	String string;
	Formatter::FormatVa(string,format,va);
	Stream->Write(string);

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Redirector::Redirector(Reason::System::Logging::Logged & logged, Reason::System::File & file):Redirect(logged)
{

}

Redirector::~Redirector()
{

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Duplicator::Duplicator(Log & first)
{
	Logs.Append(first);
}

Duplicator::Duplicator(Log & first, Log & second)
{
	Logs.Append(first);
	Logs.Append(second);
}

Duplicator::Duplicator(Log & first, Log & second, Log & third)
{
	Logs.Append(first);
	Logs.Append(second);
	Logs.Append(third);
}

Duplicator::Duplicator(Log & first, Log & second, Log & third, Log & fourth)
{
	Logs.Append(first);
	Logs.Append(second);
	Logs.Append(third);
	Logs.Append(fourth);
}

Duplicator::Duplicator(Log & first, Log & second, Log & third, Log & fourth, Log & fifth)
{
	Logs.Append(first);
	Logs.Append(second);
	Logs.Append(third);
	Logs.Append(fourth);
	Logs.Append(fifth);
}

void Duplicator::PrintVa(const char * format, va_list va)
{
	va_list val;

	Iterand<Log&> iterand = Logs.Forward();
	while(iterand != 0)
	{
		va_copy(val,va);
		iterand().PrintVa(format,val);
		va_end(val);

		++iterand;
	}

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace Reason { namespace System { namespace Logging {

StdOut Console;
StdErr Output;

}}}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

